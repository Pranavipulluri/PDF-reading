"""
Outline Preview Generator - Creates human-readable outline previews
Generates clean .txt and .md files for debugging and quick review
"""

import logging
from typing import List, Dict, Any
from pathlib import Path

class OutlinePreviewGenerator:
    """Generates clean, human-readable outline previews"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # Formatting options
        self.formatting = {
            'indent_size': 2,
            'max_text_length': 80,
            'include_page_numbers': True,
            'include_confidence_scores': False,
            'section_separator': '\n',
            'markdown_style': True
        }
    
    def generate_preview_files(self, title: str, headings: List[Dict[str, Any]], 
                             output_base_path: str) -> Dict[str, str]:
        """
        Generate multiple preview formats
        
        Args:
            title: Document title
            headings: List of detected headings
            output_base_path: Base path for output files (without extension)
            
        Returns:
            Dictionary mapping format to file path
        """
        if not headings:
            self.logger.warning("No headings provided for preview generation")
            return {}
        
        self.logger.info(f"Generating outline previews for '{title}' with {len(headings)} headings")
        
        generated_files = {}
        
        # Generate plain text preview
        try:
            txt_path = self._generate_text_preview(title, headings, output_base_path)
            generated_files['text'] = txt_path
        except Exception as e:
            self.logger.error(f"Failed to generate text preview: {e}")
        
        # Generate Markdown preview
        try:
            md_path = self._generate_markdown_preview(title, headings, output_base_path)
            generated_files['markdown'] = md_path
        except Exception as e:
            self.logger.error(f"Failed to generate Markdown preview: {e}")
        
        # Generate structured outline
        try:
            outline_path = self._generate_structured_outline(title, headings, output_base_path)
            generated_files['outline'] = outline_path
        except Exception as e:
            self.logger.error(f"Failed to generate structured outline: {e}")
        
        self.logger.info(f"Generated {len(generated_files)} preview files")
        return generated_files
    
    def _generate_text_preview(self, title: str, headings: List[Dict[str, Any]], 
                             output_base_path: str) -> str:
        """Generate plain text preview"""
        
        output_path = f"{output_base_path}_preview.txt"
        
        lines = []
        
        # Header
        lines.append("=" * 60)
        lines.append("PDF OUTLINE PREVIEW")
        lines.append("=" * 60)
        lines.append("")
        lines.append(f"Document: {title}")
        lines.append(f"Total Headings: {len(headings)}")
        lines.append("")
        
        # Statistics
        level_counts = {}
        for heading in headings:
            level = heading.get('level', 'Unknown')
            level_counts[level] = level_counts.get(level, 0) + 1
        
        lines.append("Heading Distribution:")
        for level in ['H1', 'H2', 'H3']:
            count = level_counts.get(level, 0)
            lines.append(f"  {level}: {count}")
        lines.append("")
        
        # Outline
        lines.append("DOCUMENT OUTLINE:")
        lines.append("-" * 40)
        lines.append("")
        
        for heading in headings:
            level = heading.get('level', 'H3')
            text = heading.get('text', '')
            page = heading.get('page', 0)
            
            # Calculate indentation
            indent_level = int(level[1]) - 1  # H1=0, H2=1, H3=2
            indent = ' ' * (indent_level * self.formatting['indent_size'])
            
            # Format text
            if len(text) > self.formatting['max_text_length']:
                text = text[:self.formatting['max_text_length'] - 3] + '...'
            
            # Create line
            if self.formatting['include_page_numbers']:
                line = f"{indent}{level}: {text} (Page {page})"
            else:
                line = f"{indent}{level}: {text}"
            
            lines.append(line)
        
        lines.append("")
        lines.append("=" * 60)
        lines.append("Generated by PDF Outline Extractor v2.0")
        lines.append("=" * 60)
        
        # Write file
        Path(output_path).parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
        
        self.logger.info(f"Text preview saved to: {output_path}")
        return output_path
    
    def _generate_markdown_preview(self, title: str, headings: List[Dict[str, Any]], 
                                 output_base_path: str) -> str:
        """Generate Markdown preview"""
        
        output_path = f"{output_base_path}_preview.md"
        
        lines = []
        
        # Title
        lines.append(f"# {title}")
        lines.append("")
        
        # Metadata
        level_counts = {}
        pages_covered = set()
        
        for heading in headings:
            level = heading.get('level', 'Unknown')
            level_counts[level] = level_counts.get(level, 0) + 1
            pages_covered.add(heading.get('page', 0))
        
        lines.append("## Document Statistics")
        lines.append("")
        lines.append(f"- **Total Headings:** {len(headings)}")
        lines.append(f"- **Pages with Headings:** {len(pages_covered)}")
        lines.append(f"- **Page Range:** {min(pages_covered) if pages_covered else 0}-{max(pages_covered) if pages_covered else 0}")
        lines.append("")
        
        lines.append("### Heading Distribution")
        lines.append("")
        for level in ['H1', 'H2', 'H3']:
            count = level_counts.get(level, 0)
            percentage = (count / len(headings)) * 100 if headings else 0
            lines.append(f"- **{level}:** {count} ({percentage:.1f}%)")
        lines.append("")
        
        # Table of Contents
        lines.append("## Table of Contents")
        lines.append("")
        
        for i, heading in enumerate(headings):
            level = heading.get('level', 'H3')
            text = heading.get('text', '')
            page = heading.get('page', 0)
            
            # Calculate indentation for TOC
            indent_level = int(level[1]) - 1
            indent = '  ' * indent_level
            
            # Create anchor link (simplified)
            anchor = text.lower().replace(' ', '-').replace('(', '').replace(')', '')
            anchor = ''.join(c for c in anchor if c.isalnum() or c == '-')
            
            if self.formatting['include_page_numbers']:
                toc_line = f"{indent}- [{text}](#{anchor}) *(Page {page})*"
            else:
                toc_line = f"{indent}- [{text}](#{anchor})"
            
            lines.append(toc_line)
        
        lines.append("")
        lines.append("---")
        lines.append("")
        
        # Detailed Outline
        lines.append("## Detailed Outline")
        lines.append("")
        
        current_page = None
        
        for heading in headings:
            level = heading.get('level', 'H3')
            text = heading.get('text', '')
            page = heading.get('page', 0)
            confidence = heading.get('confidence', 0)
            
            # Add page separator if needed
            if current_page != page:
                if current_page is not None:
                    lines.append("")
                lines.append(f"### Page {page}")
                lines.append("")
                current_page = page
            
            # Convert level to Markdown heading
            md_level = int(level[1]) + 2  # H1->###, H2->####, H3->#####
            md_prefix = '#' * md_level
            
            # Add confidence if enabled
            if self.formatting['include_confidence_scores'] and confidence > 0:
                confidence_badge = f" `confidence: {confidence:.2f}`"
                md_line = f"{md_prefix} {text}{confidence_badge}"
            else:
                md_line = f"{md_prefix} {text}"
            
            lines.append(md_line)
            lines.append("")
        
        # Footer
        lines.append("---")
        lines.append("")
        lines.append("*Generated by PDF Outline Extractor v2.0*")
        
        # Write file
        Path(output_path).parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
        
        self.logger.info(f"Markdown preview saved to: {output_path}")
        return output_path
    
    def _generate_structured_outline(self, title: str, headings: List[Dict[str, Any]], 
                                   output_base_path: str) -> str:
        """Generate structured outline for debugging"""
        
        output_path = f"{output_base_path}_structure.txt"
        
        lines = []
        
        # Header
        lines.append("DOCUMENT STRUCTURE ANALYSIS")
        lines.append("=" * 50)
        lines.append("")
        lines.append(f"Title: {title}")
        lines.append(f"Analysis Date: {self._get_timestamp()}")
        lines.append("")
        
        # Hierarchical analysis
        hierarchy_analysis = self._analyze_hierarchy_structure(headings)
        
        lines.append("HIERARCHY ANALYSIS:")
        lines.append("-" * 30)
        lines.append(f"Max Depth: {hierarchy_analysis['max_depth']}")
        lines.append(f"Hierarchy Consistency: {'Good' if hierarchy_analysis['is_consistent'] else 'Issues Found'}")
        lines.append("")
        
        # Level transitions
        if hierarchy_analysis['transitions']:
            lines.append("LEVEL TRANSITIONS:")
            lines.append("-" * 20)
            for transition in hierarchy_analysis['transitions'][:10]:  # Show first 10
                lines.append(f"  {transition['from']} → {transition['to']} (Page {transition['page']})")
            if len(hierarchy_analysis['transitions']) > 10:
                lines.append(f"  ... and {len(hierarchy_analysis['transitions']) - 10} more")
            lines.append("")
        
        # Detailed structure
        lines.append("DETAILED STRUCTURE:")
        lines.append("-" * 25)
        lines.append("")
        
        for i, heading in enumerate(headings):
            level = heading.get('level', 'H3')
            text = heading.get('text', '')
            page = heading.get('page', 0)
            
            # Debug information
            debug_info = []
            if 'confidence' in heading:
                debug_info.append(f"conf:{heading['confidence']:.2f}")
            if 'hierarchy_adjusted' in heading:
                debug_info.append("adjusted")
            if 'original_level' in heading:
                debug_info.append(f"was:{heading['original_level']}")
            
            debug_str = f" [{', '.join(debug_info)}]" if debug_info else ""
            
            # Format line
            indent = '  ' * (int(level[1]) - 1)
            lines.append(f"{i+1:2d}. {indent}{level}: {text} (p.{page}){debug_str}")
        
        # Issues detected
        if hierarchy_analysis['issues']:
            lines.append("")
            lines.append("ISSUES DETECTED:")
            lines.append("-" * 20)
            for issue in hierarchy_analysis['issues']:
                lines.append(f"  ⚠ {issue}")
        
        lines.append("")
        lines.append("=" * 50)
        lines.append("End of Structure Analysis")
        
        # Write file
        Path(output_path).parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
        
        self.logger.info(f"Structure analysis saved to: {output_path}")
        return output_path
    
    def _analyze_hierarchy_structure(self, headings: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze the hierarchical structure of headings"""
        
        analysis = {
            'max_depth': 0,
            'is_consistent': True,
            'transitions': [],
            'issues': [],
            'level_counts': {'H1': 0, 'H2': 0, 'H3': 0}
        }
        
        if not headings:
            return analysis
        
        prev_level = None
        
        for heading in headings:
            level = heading.get('level', 'H3')
            page = heading.get('page', 0)
            
            # Update counts
            analysis['level_counts'][level] = analysis['level_counts'].get(level, 0) + 1
            
            # Update max depth
            level_num = int(level[1])
            analysis['max_depth'] = max(analysis['max_depth'], level_num)
            
            # Track transitions
            if prev_level:
                transition = {
                    'from': prev_level,
                    'to': level,
                    'page': page
                }
                analysis['transitions'].append(transition)
                
                # Check for consistency issues
                prev_num = int(prev_level[1])
                curr_num = int(level[1])
                
                if curr_num > prev_num + 1:  # Level skipping
                    analysis['is_consistent'] = False
                    analysis['issues'].append(f"Level skip: {prev_level} → {level} on page {page}")
            
            prev_level = level
        
        # Additional consistency checks
        h1_count = analysis['level_counts']['H1']
        h2_count = analysis['level_counts']['H2']
        
        if h1_count == 0:
            analysis['issues'].append("No H1 headings found")
        
        if h1_count > 1 and h2_count == 0:
            analysis['issues'].append("Multiple H1s but no H2 headings")
        
        return analysis
    
    def _get_timestamp(self) -> str:
        """Get current timestamp for reports"""
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    def create_quick_summary(self, title: str, headings: List[Dict[str, Any]]) -> str:
        """Create a quick one-line summary for logging"""
        
        if not headings:
            return f"'{title}': No headings detected"
        
        level_counts = {}
        for heading in headings:
            level = heading.get('level', 'Unknown')
            level_counts[level] = level_counts.get(level, 0) + 1
        
        parts = []
        for level in ['H1', 'H2', 'H3']:
            count = level_counts.get(level, 0)
            if count > 0:
                parts.append(f"{count} {level}")
        
        summary = ', '.join(parts) if parts else 'No standard headings'
        return f"'{title}': {summary} ({len(headings)} total)"
    
    def generate_comparison_report(self, original_headings: List[Dict[str, Any]], 
                                 processed_headings: List[Dict[str, Any]], 
                                 output_path: str) -> str:
        """Generate a comparison report showing before/after processing"""
        
        lines = []
        
        # Header
        lines.append("HEADING PROCESSING COMPARISON REPORT")
        lines.append("=" * 50)
        lines.append("")
        
        # Statistics
        lines.append("BEFORE/AFTER STATISTICS:")
        lines.append("-" * 30)
        lines.append(f"Original headings: {len(original_headings)}")
        lines.append(f"Processed headings: {len(processed_headings)}")
        lines.append(f"Net change: {len(processed_headings) - len(original_headings):+d}")
        lines.append("")
        
        # Level distribution comparison
        def count_levels(headings):
            counts = {'H1': 0, 'H2': 0, 'H3': 0}
            for h in headings:
                level = h.get('level', 'H3')
                counts[level] = counts.get(level, 0) + 1
            return counts
        
        orig_counts = count_levels(original_headings)
        proc_counts = count_levels(processed_headings)
        
        lines.append("LEVEL DISTRIBUTION CHANGES:")
        lines.append("-" * 35)
        for level in ['H1', 'H2', 'H3']:
            orig = orig_counts[level]
            proc = proc_counts[level]
            change = proc - orig
            change_str = f"({change:+d})" if change != 0 else ""
            lines.append(f"{level}: {orig} → {proc} {change_str}")
        lines.append("")
        
        # Show changes
        lines.append("DETAILED CHANGES:")
        lines.append("-" * 20)
        
        # Find headings that were adjusted
        adjusted_headings = [h for h in processed_headings if h.get('hierarchy_adjusted', False)]
        
        if adjusted_headings:
            lines.append("Hierarchy Adjustments:")
            for h in adjusted_headings:
                orig_level = h.get('original_level', 'Unknown')
                new_level = h.get('level', 'Unknown')
                reason = h.get('adjustment_reason', 'Unknown')
                text = h.get('text', '')[:40] + ('...' if len(h.get('text', '')) > 40 else '')
                lines.append(f"  • {orig_level} → {new_level}: '{text}' ({reason})")
        else:
            lines.append("No hierarchy adjustments made.")
        
        lines.append("")
        lines.append("=" * 50)
        
        # Write file
        Path(output_path).parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
        
        self.logger.info(f"Comparison report saved to: {output_path}")
        return output_path